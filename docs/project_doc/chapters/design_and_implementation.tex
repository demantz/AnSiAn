\chapter{Design and Implementation}\label{ch:design_and_implementation}

\section{Optimizations and Bugfixes}


\subsection{Memory Optimizations\label{sec:cleanup.mem}}

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/queue_arch}
	\caption{Signal processing architecture with blocking queues}
	\label{fig:queue_architecture}
\end{figure}

The original RF Analyzer application's architecture is based on
blocking queues that synchronize the various signal processing threads
and efficiently manage memory buffers. Unfortunately, this
architecture was partly dropped by the developers of \ac{AnSiAn} when
changing to a new architecture based on the EventBus library. As a result, memory
allocation management does not work as efficiently with the current version
of \ac{AnSiAn}.

Instead of using cycling buffers for inter-thread-communication, \ac{AnSiAn} uses
EventBus to deliver data. Buffers are always allocated freshly
and discarded after use. This results in a high activity of the
\ac{GC} and therefore in a bad overall performance of the app.

\autoref{lst:before_mem_optimization} shows a logcat output of the
app before any optimizations were applied. The \ac{GC} runs approximately 8 times per second
and the slow performance results in stuttering audio demodulation on
older hardware.

\begin{lstlisting}[label=lst:before_mem_optimization, caption=Logcat output
before memory optimizations, language=none]
05-12 17:55:04.060 D/dalvikvm: GC_FOR_ALLOC freed 4347K, 14% free 54695K/62984K, paused 28ms, total 28ms
05-12 17:55:04.180 D/dalvikvm: GC_FOR_ALLOC freed 4321K, 14% free 54737K/62984K, paused 26ms, total 26ms
05-12 17:55:04.300 D/dalvikvm: GC_FOR_ALLOC freed 4507K, 14% free 54705K/62984K, paused 32ms, total 32ms
05-12 17:55:04.420 D/dalvikvm: GC_FOR_ALLOC freed 4454K, 14% free 54759K/62984K, paused 30ms, total 30ms
\end{lstlisting}

In order to fix this performance issue, the architecture is reverted
to using blocking queues and cycling buffers in places where large memory buffers are passed
between threads. EventBus is still used for delivering information
which is not tied to large buffers. A schema of the new architecture
is depicted in \autoref{fig:queue_architecture}. 

In this architecture, the buffers cycle between the threads. The re-usage
of buffers helps to reduce the memory allocation and garbage collection
overhead to a minimum. \autoref{lst:after_mem_optimization} shows the
logcat output after the architecture changes have been applied. The \ac{GC}
only needs to run every 10 to 20 seconds.


\begin{lstlisting}[label=lst:after_mem_optimization, caption=Logcat output
after memory optimizations, language=none]
05-12 17:27:29.230 D/dalvikvm: GC_FOR_ALLOC freed 3233K, 15% free 19706K/23000K, paused 32ms, total 33ms
05-12 17:27:40.780 D/dalvikvm: GC_FOR_ALLOC freed 3528K, 16% free 20235K/23824K, paused 30ms, total 31ms
05-12 17:28:00.110 D/dalvikvm: GC_FOR_ALLOC freed 4130K, 18% free 20338K/24528K, paused 36ms, total 37ms
05-12 17:28:24.520 D/dalvikvm: GC_FOR_ALLOC freed 4263K, 18% free 20341K/24664K, paused 49ms, total 49ms
\end{lstlisting}


\subsection{Bugfixes}


\section{Demodulators}
\subsection{Design and Structural Changes}

The existing architecture of \ac{AnSiAn} features individual threads for scheduling, 
downsampling, demodulation and audio output. The \texttt{De\-mo\-du\-la\-tor} thread demodulates 
quadrature samples by calling the \texttt{demodulate()} method on an instance of
\texttt{Demodulation}. \texttt{Demodulation} is an abstract class that is implemented by concrete 
demodulation methods such as \texttt{AM}, \texttt{FM} and \texttt{Morse}. 

\ac{AnSiAn} utilizes the EventBus library in order to pass demodulated Morse text
to the \ac{GUI}. Demodulated audio data is passed to the
\texttt{AudioSink} thread by enqueuing it into its input queue.
This mechanism is explained in more detail in \autoref{sec:cleanup.mem}.


In order to extend \ac{AnSiAn} with demodulation functionality for \ac{PSK31} and \ac{RDS}, 
the existing architecture needs to be extended. The extended architecture is
depicted in \autoref{fig:demod_text_eventbus} and explained in the following.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/demod_text_eventbus.png}
	\caption{Architecture of the extended demodulation logic and communication with the GUI}
	\label{fig:demod_text_eventbus}
\end{figure}

Two new classes \texttt{PSK31} and \texttt{RDS}, that inherit from
\texttt{Demodulation}, need to be implemented to represent the new demodulation 
mechanisms.

As \ac{PSK31} demodulation works on the envelope of the received signal
and \ac{AM} demodulation essentially performs envelope detection, \texttt{PSK31}
uses an instance of \texttt{AM} for envelope detection.

\ac{RDS} transmits metadata for \ac{FM} radio channels. It is therefore desirable for the 
\ac{RDS} demodulation mode to not only display this metadata, but to also play the 
\ac{FM}-modulated audio at the same time. The \texttt{RDS} class uses an
instance of \texttt{FM} for this purpose.

Like the existing architecture, the new architecture will use the EventBus
library to pass the demodulated text to the \ac{GUI}. The existing View
\texttt{MorseReceiveView} is refactored into a universal
\texttt{De\-mo\-du\-la\-tion\-In\-fo\-View} that displays the text output of any selected 
demodulator. Demodulators pass \texttt{DemodTextEvent}s and 
\texttt{DemodInfoEvent}s via the EventBus to the \texttt{De\-mo\-du\-la\-tion\-In\-fo\-View}, 
which contain demodulated text and further information (e.g. baud rates or raw 
dits and dahs) and are displayed in separate lines.

\subsection{Re-Implementation of Morse Demodulator}
\subsection{Radio Data System}

The \ac{RDS} signal is transmitted along with wide band \ac{FM}
radio signals to provide additional information about the
radio station and program.

Demodulation of the \ac{RDS} signal is first done in Octave in order to
evaluate the demodulation algorithm. The octave implementation
also helps by providing reference data of the different stages
of demodulation. 

\subsubsection{RDS modulation scheme}
\label{sec:rds_modulation_scheme}

\ac{RDS} uses \ac{BPSK} with Manchester encoding. The signal is
transmitted with an offset of 57 kHz relative to the center frequency
of the mono audio signal (baseband). The 19 kHz pilot tone of wideband \ac{FM}
can therefore be used to retrieve the \ac{RDS} carrier by multiplying
it with itself 3 times. The complete FM spectrum can be seen in
\autoref{fig:quad_demod_spectrum}.

After the \ac{RDS} baseband signal has been retrieved from the \ac{FM} signal
there are multiple ways of demodulating the \ac{BPSK} modulation. A sophisticated
approach tries to recover the phase synchronised \ac{RDS} carrier from the
signal by using e.g. a form of \ac{PLL} or Costas Loop. The symbols can then
be extracted by multiplying the carrier with the modulated signal and apply
a threshold operation to get bits.

A much simpler approach is to analyze the envelope of the signal and dectect
bits based on known shapes of ones and zeros in the waveform.
\autoref{fig:rds_envelope} shows the envelope and the pattern of symbols
which can be detected.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/rds_waveform.png}
	\caption[RDS envelope waveform after Frequency demodulation]{RDS envelope waveform after Frequency demodulation \cite{1999:iec62106}}
	\label{fig:rds_envelope}
\end{figure}



\subsubsection{RDS coding scheme}

RDS frames are called groups and each group consists of 4 blocks called
A, B, C and D. One block has a length of 16 bit plus a 10 bit checkword.
Block A always contains the \ac{PI} which identifies the radio station.
The content of the other blocks depends on the group type which is located
in block B (see \autoref{fig:rds_group0A}).

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/group0A.png}
	\caption[Coding scheme of RDS: group 0A]{Coding scheme of RDS: group 0A \cite{1999:iec62106}}
	\label{fig:rds_group0A}
\end{figure}

\autoref{tab:rds_groups} lists all group types and their descriptions.
The \ac{RDS} demodulation in AnSiAn only decodes types 0 and 2 because they contain
the basic information which is also often displayed on the radio
receiver.


\subsubsection{Evaluation in Octave}

Developing a signal processing application on Android has many drawbacks. One
issue is that it is very hard to debug the actual signal processing components
because of the lack of proper tools to visualize and analyze the data that is
being processed. It is also not possible to do rapid prototyping without
sufficient signal processing libraries available. Therefore the \ac{RDS}
demodulator was first developed in Octave and afterwards ported to Android.

For development and testing it is better to work on recorded samples instead
of live captures. This makes tests reproducible and simplify the development
environment. The file was recorded using the record feature of RF Analyzer. It
can be imported to Octave by using the \emph{read\_cuchar\_binary()} script
provided by the GNU Radio project. After each step the produced output data
can be written back to an \emph{IQ} file in order to use it in the Android application.
This way it is possible to develop each component of the demodulation process
separately and the output can be visualized on the developing machine.

The demodulation is done in the following steps:
\begin{enumerate}
	\item Downmixing the radio signal to baseband and filter it (see 
		\autoref{fig:rds_downmixing}).
	\item \ac{FM} demodulation (see \autoref{fig:quad_demod_spectrum}).
	\item Downmixing the \ac{RDS} signal to baseband and filter it
		(see \autoref{fig:rds_extraction} b and c).
	\item Take the absolute value of the signal to get the envelope
		that was shown above (see \autoref{fig:rds_waveform}).
	\item Find the beginning of a symbol by searching for a minimum in
		the waveform. From there find the end of the symbol with the
		same strategy. Now determine whether the symbol is a one or a
		zero according to the value of the minimum found in the middle
		of the sample compared to its peaks.
\end{enumerate}

\begin{figure}
\subfloat[Spectrum of the captured signal]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/raw_signal_spectrum.png}%
}

\subfloat[Spectrum after downmixing and filtering]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/fm_baseband_filtered_spectrum.png}%
}
\caption{FM Modulated Signal}
\label{fig:rds_downmixing}
\end{figure}


\begin{figure}
\subfloat[Signal spectrum after FM demodulation]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/quad_demod_spectrum.png}%
  \label{fig:quad_demod_spectrum}
}

\subfloat[RDS baseband spectrum after downmixing]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/rds_baseband_unfiltered_spectrum.png}%
}

\subfloat[RDS baseband spectrum after filtering]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/rds_baseband_spectrum.png}%
}
\caption{Extracting the RDS signal from the FM signal}
\label{fig:rds_extraction}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/rds_magnitude_waveform.png}
	\caption{RDS waveform after take the absolute values}
	\label{fig:rds_waveform}
\end{figure}

The octave code used to execute the steps mentioned above is shown in the
listing below:

\begin{lstlisting}[label=lst:octave_rds, caption=Octave implementation of the RDS demodulator, language=none]
signal = read_cuchar_binary ("~/Downloads/2016-06-01-20-17-18_rtlsdr_100550000Hz_1000000Sps.iq" );
t = linspace(0, length(signal)/1000000, length(signal))';
carrier = e.^(2*pi*-245000*t*i);
down = carrier .* signal;
fl = fir1(300, 100000/1000000*2);
filtered = filter(fl, 1, down);
demod = quad_demod(filtered, 1);
t2 = linspace(0, length(demod)/1000000, length(demod));
rdscarrier = cos(2*pi*-57000*t2)';
rdsbase = demod(1:length(rdscarrier)) .* rdscarrier ;
frds = fir1(300, 2400/1000000*2);
rdsbase_filtered = filter(frds,1,rdsbase);
downsampled = decimate(rdsbase_filtered, 16).*80;
write_cuchar_binary (downsampled, "~/Downloads/rds_baseband_62500sps.iq");
bits = rds_bpsk_demodulate(downsampled, 62500);
rds_decode(bits)
\end{lstlisting}

The \emph{quad\_demod()} function does the quadrature demodulation
(FM demodulation). The \emph{rds\_bpsk\_demodulate()} function is shown
in the following listing:

\begin{lstlisting}[label=lst:octave_rds_bpsk, caption=Octave implementation of the BPSK demodulation, language=none]
function demod = rds_bpsk_demodulate(signal, fs)
  samples_per_symbol = fs/1187.5
  samples_per_symbol = ceil(samples_per_symbol)
  envelope = abs(signal);
  
  % Find the first minimum
  [minimum, idx1] = min(envelope(1:samples_per_symbol))
  
  bits = [];
  while (idx1 + samples_per_symbol*2 < length(envelope))
    % find end of symbol idx2 (minimum near idx1 + samples_per_symbol)
    from = round(idx1+samples_per_symbol*0.75);
    to   = round(idx1+samples_per_symbol*1.25);
    [minimum, idx2] = min(envelope(from:to));
    idx2 = idx2 + from;
    
    % calc mean of all samples between idx1 and idx2 and calc threshold = mean/2
    m = mean(envelope(idx1:idx2));
    threshold = m/2;
    
    % get minimum sample in the middle between idx1 and idx2 ...
    span = idx2 - idx1;
    from = round((idx1+idx2)*0.5 - 0.25*span);
    to   = round((idx1+idx2)*0.5 + 0.25*span);
    [minimum, idxmiddle] = min(envelope(from:to));
    idxmiddle = idxmiddle + from;
    
    % Check whether we have the correct timing. It might be, that idx2 is
    % actually in the middle of a symbol than at its end.
    if (envelope(idx2) > threshold)
      % In this case we find the minimum between idx1 and idx2 and set it
      % as idx1 for the next round:
      %printf("WARNING: Wrong timing. thres=%f < envelope(idx2=%d)=%f\n",threshold,idx2,envelope(idx2));
      idx1 = idxmiddle;
      continue;
    endif
    
    % ... and check it against the threshold
    s = envelope(idxmiddle);
    if (s > threshold)
      bits = [bits 1];
    else
      bits = [bits 0];
    endif
    
    % idx1 = idx2 and continue with the next symbol..
    idx1 = idx2;
    
  endwhile
  demod = bits;
\end{lstlisting}


\subsubsection{Android Implementation}

For the Android implementation two classes are added to the AnSiAn codebase:
\begin{itemize}
	\item BPSK: This class handles the \ac{BPSK} demodulation and can be
		reused by other demodulators using the \ac{BPSK} modulation scheme
		(e.g. PSK31).
	\item RDS: This class integrates in the existing FM class for frequency
		demodulation. It handles the decoding and processing of \ac{RDS}
		groups. 
\end{itemize}

A screenshot of the application demodulating the \ac{RDS} signal of the
\emph{Antenne Frankfurt} station is shown in \autoref{fig:rds_android_screenshot}.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/android_screenshot.png}
	\caption{Screenshot of the RDS demodulator on a Nexus 7}
	\label{fig:rds_android_screenshot}
\end{figure}


\subsection{PSK31}

\ac{PSK31} refers to phase shift keying modulation using a baud rate of 31.25
Hz.  It was developed by Peter Martinez in 1998 to introduce a narrow bandwidth
digital mode for live chatting. Because of the simple and efficient modulation
and coding scheme (e.g. it does not have an error correction mechanism) it is
very widespread amongst amateur radio operators.

A typical setup for \ac{PSK31} operation is a \ac{SSB} transceiver connected
to the sound card of a computer. The audio channel that is fed into the computer
can contain multiple parallel \ac{PSK31} transmissions, which are demodulated
using a special software.

PSK31 is usually operated in \ac{USB} mode and shall therefore be available
in \ac{AnSiAn} when the \ac{USB} demodulator is active.
As with the \ac{RDS} demodulator the algorithm to demodulate and decode \ac{PSK31}
is first evaluated in Octave and later ported to the \ac{AnSiAn} application.

\subsubsection{PSK31 modulation scheme}

\ac{PSK31} in its basic form uses \ac{BPSK} to transmit binary information by
sending a single side band signal with either a 180 degree phase shift (digital
'1') or without a phase shift (digital '0'). Additionally a root raised cosine
filter is used in order to smooth the phase shift and therefore keep the
bandwidth narrow.  Each symbol contains information about one bit and is always
32 ms long.

\autoref{fig:psk31_modulation} shows the modulated \ac{PSK31} signal. As already
explained in \autoref{sec:rds_modulation_scheme}, the signal may be demodulated
by using a second order loop (e.g. a costas loop) in order to recover the phase
information and correct for small frequency variations. However the simple approach
using envelope detection is also possible. The \ac{BPSK} code used for \ac{RDS}
demodulation can be partly reused and only needs some modifications as \ac{PSK31}
does not use Manchester Encoding.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/psk31/psk31_modulation.png}
	\caption{PSK31 modulation scheme: Each symbol is 32ms long. A $180°$ phase
	shift indicates a '0', no phase shift indicates a '1'}
	\label{fig:psk31_modulation}
\end{figure}

\subsubsection{PSK31 coding scheme}

\ac{PSK31} uses a variable length encoding called \emph{Varicode} which assigns
frequently used characters a shorter code similar to morse. Characters are separated
by two consecutive zeros. \autoref{tab:psk31_varicode} in the appendix lists all
characters and their varicode encodings.

\subsubsection{Evaluation in Octave}

The demodulation algorithm in octave comprises the following steps:
\begin{enumerate}
	\item Downmixing the \ac{USB} signal to baseband.
	\item \ac{USB} demodulation (complex bandpass filter to
		get only the upper side band). See \autoref{fig:psk31_signal_spectrum} b.
	\item Downsampling in order to reduce the workload for the PSK31 demodulation.
	\item Envelope detection. See \autoref{fig:psk31_envelope}.
	\item Find the beginning of a '0' symbol by searching for a minimum in the
		envelope of the signal. Determine whether the next symbol is a '0' (another
		minimum is found around 32ms from the beginning of the current symbol) or
		a '1' (no minimum at the beginning of the next symbol). If another '0' was
		detected, the timing can be corrected by centering the minimum at the beginning
		of the signal and search on from there.
\end{enumerate}

\begin{figure}
\subfloat[Raw spectrum. The PSK31 signal is at around 55 KHz.]{%
  \includegraphics[clip,width=1\linewidth]{gfx/psk31/psk31_raw_signal.png}%
}

\subfloat[Spectrum after downmixing and filtering (USB demodulation)]{%
  \includegraphics[clip,width=1\linewidth]{gfx/psk31/psk31_usb_demod.png}%
}
\caption{PSK31 signal in the frequency domain (spectrum)}
\label{fig:psk31_signal_spectrum}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/psk31/psk31_envelope.png}
	\caption{Envelope of the downsampled, USB demodulated signal.}
	\label{fig:psk31_envelope}
\end{figure}

The octave code used to execute the steps mentioned above is shown in the
listing below:

\begin{lstlisting}[label=lst:octave_psk31, caption=Octave implementation of the PSK31 demodulator, language=none]
% load signal
signal = read_cuchar_binary ("rtlsdr_434570917Hz_1000000Sps.iq");
fs = 1000000;

% downmixing (signal is at ~ 55 Khz)
fc = 55000;
t = linspace(0, length(signal)/fs, length(signal))';
carrier = e.^(2*pi*-fc*t*i);
down = carrier .* signal;

% USB demod (bandpass filter [200Hz-1000Hz])
bpfilter = firls(300, [0 200 200 1000 1000 fs/2]./(fs/2), [0 0 0 1 0 0]);
filtered = filter(bpfilter, 1, down);

% downsampling
downsampled = decimate(filtered, 16);

% BPSK demodulation
bits = psk31_bpsk_demodulate(downsampled, fs/16);

% Varicode decoding
psk31_decode(bits)
\end{lstlisting}

The \emph{psk31\_bpsk\_demodulate()} function is shown in the following listing:

\begin{lstlisting}[label=lst:octave_psk31_bpsk, caption=Octave implementation of the BPSK demodulation, language=none]
function demod = psk31_bpsk_demodulate(signal, fs)
  % PSK31 baud rate is 31.25 Hz
  samples_per_symbol = fs/31.25
  samples_per_symbol = ceil(samples_per_symbol)
  envelope = abs(signal);
  
  % Find the first minimum
  [minimum, idx1] = min(envelope(1:samples_per_symbol))
  
  bits = [];
  while (idx1 + samples_per_symbol*2 < length(envelope))
    % search for a minimum at the position of the next sample
    % (minimum near idx1 + samples_per_symbol)
    from = round(idx1+samples_per_symbol*0.5);
    to   = round(idx1+samples_per_symbol*1.5);
    [minimum, idx2] = min(envelope(from:to));
    idx2 = idx2 + from;
    
    % calc mean of all samples between idx1 and idx2 and calc threshold = mean/2
    m = mean(envelope(idx1:idx2));
    threshold = m/2;
    
    % Check whether we have a minimum (->0) or not (->1).
    if (envelope(idx2) > threshold)
      % In this case we have a bit 1.
      bits = [bits 1];
      idx1 = idx1 + samples_per_symbol;
    else
      % In this case we have a bit 0.
      bits = [bits 0];
      idx1 = idx2;
    endif
  endwhile
  demod = bits;
\end{lstlisting}

\subsubsection{Android Implementation}

For the Android implementation the \emph{BPSK} class is modified to handle both
\ac{BPSK} variations needed in \ac{AnSiAn}:
\begin{itemize}
	\item RDS: BPSK with Manchester Encoding
	\item PSK31: BPSK without Manchester Encoding
\end{itemize}

Additionally the class \emph{PSK31} is added which is a subclass of \emph{Demodulation}.
It integrates with the existing \emph{USB} class to provide PSK31 demodulation
when USB demodulation is active.

A screenshot of the application demodulating a \ac{PSK31} signal is shown in 
\autoref{fig:psk31_android_screenshot}.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/psk31/psk31_android_screenshot.png}
	\caption{Screenshot of the PSK31 demodulator on a Nexus 7}
	\label{fig:psk31_android_screenshot}
\end{figure}


\section{GUI}
\subsection{Reorganization of Preferences}
\subsection{Transmit Tab}

\section{Support for new SDR Platforms}

\ac{AnSiAn} supports different \ac{SDR} hardware such as:
\begin{itemize}
	\item RTL-SDR dongle
	\item HackRF
\end{itemize}

The architecture of the app allows to easily add support for additional hardware,
as long as it provides IQ data samples and an Android driver is available.

\subsection{rad1o}

The \emph{rad1o} is a \ac{SDR} platform with the same design as the
\emph{HackRF} that was used as badge for the \emph{Chaos Communication Camp}
2015. Some modifications to the design were made in order to reduce costs and
therefore minor differences exist compared to a HackRF (e.g. the option to
activate the antenna power is missing for the \emph{rad1o}).

The \emph{rad1o} offers the same USB interface as the \emph{HackRF} and can be
used with the same driver, which is \emph{hackrf\_android}. The driver only needs
two minor modifications:
\begin{enumerate}
	\item If the driver detects a rad1o, the option to enable the antenna power
		is disabled.
	\item Because the \emph{rad1o} has a different USB product ID, the driver has
		to be extended in order to also detect a \emph{rad1o} as valid \emph{HackRF}.
\end{enumerate}

Both changes have been applied to the \emph{hackrf\_android} driver. Unfortunately, the
creators of \ac{AnSiAn} have replaced the driver library with a plain copy of the driver
source code, which makes it hard to update it to a newer version. Therefore the
driver code was removed from \ac{AnSiAn} and replaced again with the current version
of the driver library.

This is the only change necessary to add support for the new \ac{SDR} hardware. 
The rad1o can now be used by selecting the \emph{HackRF} source in \ac{AnSiAn}.


\subsection{SDRPlay}

The \emph{SDRplay} is a low cost \ac{SDR} with a frequency range between 100 kHz and
2 GHz. It has a 12-bit \ac{ADC} and therefore suffers less from quantification noise
than the \emph{HackRF} and the \emph{RTL-SDR} (both having a 8-bit \ac{ADC}).
Additionally it provides passive \ac{RF} filters on the front end to prevent strong
out-of-band noise from distorting the input signal.

Martin Marinov developed an Android driver for the \emph{SDRplay} dongle, which
is currently in beta state. The API is similar to the \emph{RTL-SDR} driver which is
developed by the same person.

\subsubsection{Implementation}

The \emph{SDRplay} driver is started by an Intend with an URL of the format
\emph{'iqsrc://\ldots'}. It takes an IP address and TCP port as arguments and
will open a socket respectively. The host app can the connect to the socket and
will receive the samples via TCP. Control commands such as changing the
frequency, sample rate or other parameters can be sent through the TCP socket
to the driver. A list of supported commands can be found on the GitHub page
of the driver. They are listed in \autoref{tab:sdrplay_cmds}.


\begin{table}
	\begin{center}
		\begin{tabular}{l c l}
			Command name & Code & Description \\\hline
			SET\_FREQ & 0x01 & Change the tuning (center) frequency of the dongle \\
			SET\_SAMPLE\_RATE & 0x02 & Change the sample rate of the dongle \\
			SET\_GAIN\_MODE & 0x03 & Change gain mode (auto or manual) \\
			SET\_GAIN & 0x04 & Change gain value (if gain mode is manual) \\
			SET\_FREQ\_CORRECTION & 0x05 & Change frequency correction value (in ppm) \\
			SET\_IF\_TUNER\_GAIN & 0x06 & Change \ac{IF} gain \\
			SET\_TEST\_MODE & 0x07 & Turn on test mode \\
			SET\_AGC\_MODE & 0x08 & Activate or deactivate \ac{AGC} \\
			SET\_DIRECT\_SAMPLING & 0x09 & Activate or deactivate direct sampling mode \\
			SET\_OFFSET\_TUNING & 0x0a & Activate or deactivate offset tuning \\
			EXIT & 0x7e & Cause the driver to turn off itself \\
			GAIN\_BY\_PERCENTAGE & 0x7f & Change gain value as percentage \\
			ENABLE\_16\_BIT\_SIGNED & 0x80 & Enable 16 bit unsigned sample size (SDRplay only) \\\hline
		\end{tabular}
		\caption{Commands for the RTL-SDR / SDRplay driver by Martin Marinov}
		\label{tab:sdrplay_cmds}
	\end{center}
\end{table}



\subsubsection{Open Issues}

As the \emph{SDRplay} Android driver is still in beta stage, the support in AnSiAn has
also still beta status. 12-bit samples are currently not working correctly and
therefore \ac{AnSiAn} uses the RTL-SDR compatibility mode of the driver which
delivers stripped 8-bit samples. However, the 12-bit converter code is ready to
be used and might be enabled in future versions of \ac{AnSiAn}.


\section{Transmission}

RF Analyzer as well as \ac{AnSiAn} both have a receive-only signal processing
chain, even though they support \ac{SDR} devices which are capable of transmitting
signals, such as the \emph{HackRF}.
The implementation of a complete transmission chain is split into multiple steps
to go along with the Agile approach.

In the first step the transmission chain will only include the \emph{IQ Sink} which is
able to replay a recorded IQ file. The file has to have the correct format according
to the \ac{SDR} hardware and the sample rate cannot be adjusted.

The second step will provide \emph{Modulators} for some digital and analog modes along
with a dummy transmission chain which will use the modulator to create an IQ
file and feed it to the \emph{IQ sink} directly.

In the final step the dummy chain is replaced by the complete transmission chain
which includes:
\begin{itemize}
	\item the \emph{Modulators} from step two
	\item the \emph{Interpolator} which is able to adjust the sample rate at the 
		output of the \emph{Modulators} to a value that is supported by the \emph{IQ Sink}
	\item a float-to-binary converter which will output the samples in the correct
		binary format according to the \ac{SDR} hardware
\end{itemize}

After the final step the transmission chain will be able to modulate and transmit
signals in real-time, assuming the Android device is capable of the necessary
calculations.

Step one and two are part of the third sprint and provide a proof-of-concept
implementation to demonstrate the transmission capabilities of the app.
Step three will be left for future work on the application as well as the
addition of more modulators.


\subsection{Transmission of Raw I/Q Files}



\subsection{Modulators}

Each \emph{Modulator} will provide an interface to retrieve the next packet of
modulated samples. The payload data (e.g. audio or text) might be given at
instantiation time or through a queue (in order to enable real-time transmission).

As mentioned above, the step two implementation will include a dummy transmission
chain that reads the output of the \emph{Modulator}, converts it to binary IQ
data and writes it to a temporary file which will then be transmitted by the
\emph{Transmitter} implemented in the previous section.


\subsubsection{Morse Modulator}

The morse modulator takes a string as input payload and produces a baseband
signal with dits and dahs respectively. The morse encoder from the previous
\ac{AnSiAn} version can be reused to transform the payload text into a
sequence of dits ('.'), dahs ('-'), breaks ('\textvisiblespace') and word
boundaries ('/'). Each character in this sequence corresponds to a predefined
packet of IQ samples (see \autoref{tab:morse_modulation}).

Because the dit and dahs each also contains silence of the length of one dit at
the beginning, the letter separator ('\textvisiblespace') and the word separator
('/') need to be one dit length shorter than they actually are.

To increase the modulation performance, the complex sinusoid is generated
ahead of time and the character translation only consists of a copy operation.

\begin{table}
	\begin{center}
		\begin{tabular}{c l}
			Morse element & Corresponding IQ sample structure \\\hline
			. & one dit length of silence + one dit length of tone \\
			- & one dit length of silence + three dit lengths of tone \\
			\textvisiblespace & two dit lengths of silence \\
			/ & six dit lengths of silence \\\hline
		\end{tabular}
		\caption{Translation from morse elements to IQ samples}
		\label{tab:morse_modulation}
	\end{center}
\end{table}


\subsubsection{PSK31 Modulator}

The PSK31 modulator also takes a string as input payload, encodes it with
Varicode and modulates the bits with \ac{BPSK}. The Varicode dictionary of
the PSK31 demodulator can be reused to perform the first step of creating
the bitstream from the payload text. The \ac{BPSK} modulation simply outputs
the samples based on the current state (phase) of the modulator (see
\autoref{tab:bpsk_modulation}).

\begin{table}
	\begin{center}
		\begin{tabular}{c c | c}
			Previous state (phase) & Current bit & BPSK output \\\hline
			0° & 0 & $cos(\frac{\pi \cdot 31.25 Hz \cdot t}{f_s})$ \\
			180° & 0 & $-cos(\frac{\pi \cdot 31.25 Hz \cdot t}{f_s})$ \\
			0° & 1 & 1 \\
			180° & 1 & -1 \\\hline
		\end{tabular}
		\caption{Output of the BPSK modulation based on its previous state}
		\label{tab:bpsk_modulation}
	\end{center}
\end{table}
